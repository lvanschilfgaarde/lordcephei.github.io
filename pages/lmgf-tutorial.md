---
layout: page-fullwidth
title: "ASA Green's function package tutorial"
subheadline: ""
show_meta: false
teaser: ""
permalink: "/lmgf-tutorial/"
header: no
---

### _Table of Contents_
{:.no_toc}
*  Auto generated table of contents
{:toc} 

### _Preliminaries_
_____________________________________________________________
For this tutorial the **blm**{: style="color: blue"}, **lmchk**{: style="color: blue"}, **lmstr**{: style="color: blue"}, **lm**{: style="color: blue"} and **lmgf**{: style="color: blue"} executibles are required and are assumed to be in your PATH; the source code for all Questaal exectuables can be found [here](https://bitbucket.org/lmto/lm).


### _Purpose_
_____________________________________________________________
This package implements the ASA local spin-density approximation using Green's functions. The Green's functions are contructed by approximating KKR multiple-scattering theory with an analytic potential function. The approximation to KKR is essentially similar to the linear approximation employed in band methods such as LMTO and LAPW. It can be shown that this approximation is nearly equivalent to the LMTO hamiltonian without the "combined correction" term. With this package a new program, **lmgf**{: style="color: blue"} is added to the suite of executables. **lmgf**{: style="color: blue"} plays approximately the same role as the LMTO-ASA band program **lm**{: style="color: blue"}: a potential is generated from energy moments $$Q_0$$, $$Q_1$$, and $$Q_2$$ of the density of states. in the same way as the **lm**{: style="color: blue"} code. You can use **lmgf**{: style="color: blue"} to make a self-consistent density as you can do with **lm**{: style="color: blue"}. lmgf is a Green's function method: Green's functions have less information than wave functions, so in one sense the things you can do with lmgf are more limited: you cannot make the bands directly, for example. However **lmgf**{: style="color: blue"} enables you do do things you cannot do with **lm**{: style="color: blue"}. The two most imprortant are:

+ Calculate magnetic exchange interactions 
+ Calculate magnetic susceptibility (spin-spin, spin-orbit, orbit-orbit parts)
+ Calculate properties of disordered materials, either chemically disordered or spin disorder from finite temperature, within the Coherent Potential Approximation, or CPA.
+ Calculate the ASA static susceptibility at $$q=0$$ to help converge calculations to self-consistency. 

**You can find some extra information on the way** **lmgf**{: style="color: blue"} **works in** [lmgf documentation](https://lordcephei.github.io/lmgf-documentation/).

##### _lmgf vs lm_


**lmgf**{: style="color: blue"} is a Green's function program complementary to the ASA band code **lm**{: style="color: blue"}. For some properties, e.g. calculating moments $$Q_{0..2}$$ **lmgf**{: style="color: blue"} can be straightforwardly substituted for lm because both calculate the DOS. The DOS is $$1/(2\pi ) {\rm Im} G$$: it can be decomposed into site contributions and thus moments Q0..2 can be generated for each site and l channel, as an alternative to decomposing the eigenfunctions of the bands, as lm does. Thus it can achieve self-consistency in a manner similar to lm, but generating $$Q_{0..2,{\bf R}l}$$ by an alternate route. If the ASA hamiltionian built by lm is suitably simplified, i.e. by

+ omitting the "combined correction term" (**OPTIONS_ASA_CCOR**)
+ generating $$Q_{0..2,{\bf R}l}$$ from true power moments as the Green's function does (**HAM_QASA=0**), 

then **lmgf**{: style="color: blue"} and **lm**{: style="color: blue"} will produce nearly identical self-consistent solutions. When potential functions are parameterized to 2nd order in both **lm**{: style="color: blue"} and **lmgf**{: style="color: blue"}, and both methods are fully k converged, they should product nearly identical results. By default lm parameterizes the potential function to 3rd order; **lmgf**{: style="color: blue"} can do the same. The 3rd order parameterizations are similar in the two methods, but not identical. To verify this, try the following test:

~~~
gf/test/test.gf co 1 2   ← Test 1 for 2nd order parameterization; test 2 for 3rd order
~~~

**lmgf**{: style="color: blue"} is a bit messier to work with (Green's functions are harder to stabilize than wave functions), and it a bit less accurate as the simplifications to lm amount to approximations. So, typically lm makes a better self-consistent potential.

But **lmgf**{: style="color: blue"} can do things **lm**{: style="color: blue"} doesn't do, e.g. calculate magnetic exchange interactions through linear response as this tutorial demonstrates. Sometimes there is a need or advantage to carrying self-consistency via **lmgf**{: style="color: blue"}, e.g. when performing CPA calculations. Unless there is good reason to do otherwise, it is better use the self-consistent potential generated by **lm**{: style="color: blue"} to calculate other properties such as the magnetic exchange parameters. We follow that strategy here. 

### _Tutorial_
_____________________________________________________________

##### _1\. Building input file_
_____________________________________________________________

Before starting working with this tutorial we advise you to read through the [ASA-tutorial](https://lordcephei.github.io/asa-doc/) which explains building the imput file in more details (you can also look through the input described in a [full-potential context](https://lordcephei.github.io/buildingfpinput/)). In the present tutorial we'll focus on the part of the input specific for using with **lmgf**{: style="color: blue"}.

To get started, **copy** **doc/demos/asa-copt/init.copt**{: style="color: green"} to your working directory. Inspect the init file and you will see it contains just the minimum structural information, apart from one line supplying some information about the magnetic structure:

<div onclick="elm = document.getElementById('foobar'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Click to show.</button></div>
{::nomarkdown}<div style="display:none;margin:0px 25px 0px 25px;"id="foobar">{:/}

    LATTICE
             ALAT=7.1866
             PLAT=    1.000000   0.000000   0.000000
                      0.000000   1.000000   0.000000
                      0.000000   0.000000   1.000000
    SPEC ATOM=Co MMOM=0,0,2.2
    SITE
          ATOM=Pt POS=  0.0  0.0   0.0 
          ATOM=Co POS=  0.5  0.5   0.0 
          ATOM=Co POS=  0.0  0.5   0.5
          ATOM=Co POS=  0.5  0.0   0.5 

{::nomarkdown}</div>{:/}

Then **use the** **blm**{: style="color: blue"} tool (described in more details in [ASA-tutorial](https://lordcephei.github.io/asa-doc/) and [full-potential tutorial](https://lordcephei.github.io/buildingfpinput/). )

~~~
blm --mag --nk=8 --asa --gf copt
~~~

**blm**{: style="color: blue"} should generate file **actrl.copt**{: style="color: green"}, which should be essentially the same as **doc/demos/asa-copt/ctrl.copt**{: style="color: green"} (commented lines might be different though). If this is not the case, something is wrong with your configuration. **You should not continue** if your template does not agree with the one supplied.

The command-line arguments are not required, but they supply quantities **blm**{: style="color: blue"} cannot determine automatically, that you will have to supply at some point. If you supply them on the command-line they are folded into the ctrl file at the outset; or, you can edit the ctrl file after it is generated. Command-line switches **blm**{: style="color: blue"} recognizes are summarized in [Building FP input file](https://lordcephei.github.io/buildingfpinput/). 

###### _The \-\-asa switch_

This switch tailors the ctrl file for the ASA. To see how it affects the ctrl file, try running **blm**{: style="color: blue"} without **\-\-asa**{: style="color: green"}. For more details see the [ASA-tutorial](https://lordcephei.github.io/asa-doc/).

###### _The \-\-mag switch_

This switch tells **blm**{: style="color: blue"} that you plan on doing a spin polarized calculation. All it does is change the preprocessor variable _nsp_ to 2. This turns on the spin polarization through **NSPIN={nsp}**.

Without any other information the spin polarized calculation will proceed with zero magnetic moment. You have to supply some initial information about the magnetic structure. Since we know that the magnetization is concentrated on the Co (Pt is paramagnetic, though it has a high magnetic susceptibility), the init file supplies an initial magnetic moment on the Co site of about 2 Bohr on the Co d orbital, in the SPEC category (**SPEC ATOM=Co MMOM=0,0,2.2** in the initial file). Of course the actual magnetic moment is determined self-consistently later.

###### _The \-\-gf switch_

When **\-\-gf**{: style="color: green"} is used, **blm**{: style="color: blue"} prepares the input file for the Green's function program **lmgf**{: style="color: blue"}. This tutorial uses **lmgf**{: style="color: blue"} to calculate magnetic exchange interactions.  Adding **\-\-gf**{: style="color: green"} to the **blm**{: style="color: blue"} command line argument modifies **actrl.copt**{: style="color: green"} in two ways:

**1\. The GF category is created:**{: style="color: orange"}

~~~
% const gfmode=1 c3=t
GF      MODE={gfmode} GFOPTS={?~c3~p3;~p2;}
~~~

To see the purpose of **GF_MODE**, do:

~~~
lmgf --input
~~~

and look for **GF_MODE**. You should see:

~~~
    GF_MODE           reqd   i4       1,  1          default = 0
           0: do nothing
           1: self-consistent cycle
           10: Transverse exchange interactions J(q), MST
           11: Read J(q) from disk and print derivative properties
           ...
~~~
So, if **MODE=1**, **lmgf**{: style="color: blue"} does a self-consistent calculation, generating the _P_ and $$Q_{0..2}$$ for each _l_ channel using Green's functions rather than wave functions as **lm**{: style="color: blue"} does. 

**GFOPTS** bundles a variety of lmgf-specific options, which you supply through a sequence of strings separated by semicolons. This tag: 

~~~
GFOPTS={?~c3~p3;~p2;}
~~~

becomes **GFOPTS=p3** after parsing by the preprocessor, because _c3_ is nonzero (see preprocessor documentation). 
_p3_ tells **lmgf**{: style="color: blue"} to use $$3^{rd}$$ order potential functions (somewhat more accurate than $$2^{nd}$$ order, but also prone to generating false poles not too far from the real axis).

**2\. EMESH is added to BZ:**{: style="color: orange"}

~~~
% const nz=16 ef=0
        EMESH={nz},10,-1,{ef},.5,.3  # nz-pts;contour mode;emin;emax;ecc;bunching
~~~

Green's functions are energy resolved; thus physical properties such as the charge density or magnetic exchange interactions require an integration over the energy as well as over the BZ. For both density and static exchange interactions, the integration must be taken on the real axis from below the lowest eigenstate in the system to the Fermi level $$E_F$$. Im _G_ is basically the density-of-states. It is very spikey on the real axis, and a very fine energy mesh would be required to integrate Im _G_ close to the real axis. The integration can be accomplished with vastly greater ease by deforming the contour into an elliptical path in the complex plane. A gaussian quadrature is used; typically 15 or so energy points is sufficient for a well converged result.

This contour is specified through **EMESH**. Breaking down the constituents of **EMESH** as autogenerated by **blm**{: style="color: blue"}: 

~~~
     EMESH={nz}          ←  number of energy points in the contour; {nz} evaluates 16 in this file
            10           ←  elliptical contour
            -1           ←  starting energy on the contour.  Must be deeper than the lowest state in the system (-0.776 Ry)
           {ef}          ←  Fermi level determined by charge neutrality; see below
           0.5           ←  eccentricity of the ellipse ranging from 0 (circle) to 1 (line)
           0.3           ←  bunching parameter, bunching points near Ef. 0→no bunching
~~~

We don't know what $$E_F$$ is _a priori_. In the ASA, a general reasonable guess is 0. If we perform the band calculation, see [ASA-tutorial](https://lordcephei.github.io/asa-doc/), we get $$E_F$$ generated by **lm**{: style="color: blue"}: it is _−0.12927 Ry_. $$E_F$$ is fixed by charge neutrality. If **lmgf**{: style="color: blue"} generated exactly the same spectrum as **lm**{: style="color: blue"}, and the k-integration were fully converged (or at least identical in the two cases) $$E_F$$ would be the same for **lm**{: style="color: blue"} as for **lmgf**{: style="color: blue"}. However we can expect that the charge neutrality points will slightly different in the two methods.  Further we'll find $$E_F$$ using **lmgf**{: style="color: blue"}. 

##### _2\. Making ctrl file_
_____________________________________________________________

Invoking **blm**{: style="color: blue"} with the switches given above is sufficient to make a working input file. Normally you can **copy** **actrl.copt**{: style="color: green"} to **ctrl.copt**{: style="color: green"} as it is.

For a fuller description of the ctrl file, see the the [ASA-tutorial](https://lordcephei.github.io/asa-doc/), the [FP tutorial](https://lordcephei.github.io/lmf_tutorial/), and also [Building FP input file](https://lordcephei.github.io/buildingfpinput/). 

##### _3\. The Green's function program lmgf_
_____________________________________________________________

###### _a) Finding $$E_F$$_{: style="color: orange"}

If $$GF_MODE=1$$, **lmgf**{: style="color: blue"} will generate the $$Q_{0..2,{\bf R}l}$$ for whatever $$E_F$$ you give it. However there is only one physcially meaningful $$E_F$$ -- the one that satifies charge neutrality. The input file is constructed so you can supply $$E_F$$ through command-line argument **-vef=expr**{: style="color: green"}: the preprocessor evaluates  ef  from  expr, substitutes it for  {ef}  in the input file (see preprocessor documentation).

The simplest way to find the charge neutrality point is to run **lmgf**{: style="color: blue"} interactively in the self-consistent mode (**GF_MODE=1**). By running **lmgf**{: style="color: blue"} interactively you can monitor convergence. Do: 
